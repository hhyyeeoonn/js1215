<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>

	// 1) 객체(프로토타입 제일 처음 만든 원본객체)를 복사
	let s1 = {
				name : null
				, grade : 0
				, gender : null
				, study : function(){
						alert('공부한다')
						}
	}; // 객체리터럴을 사용
	
	s1.name = '루피';
	s1.grade = 7;
	s1.age = 19;
	s1.gender = '남';
	alert(s1.name);
	s1.study();
	
	let s2 = {
				name = null
				, grade : 0
				, age : 0
				, gender : null
				, study : function () {
						alert('공부한다')
				}
	};
	s2.name = '조로';
	console.log(s2.name);
	s2.study();
	
	// 2) 객체를 반환하는 함수를 이용한다
	let getStudent = function() { // function getStudent() {}
		return {
					name : null
					, grade : 0 
					, age : 0
					, gender : null
					, study : function() {
							console.log('공부한다');
					} // 만들어진 생성자를 반환하고 있음
		};
	}
	s3 = getStudent(); // == s3 = Student(); 생성자아님 // 자바문법... Student s3 = new Student();
	s3.name = '나미';
	console.log(s3.name);
	s3.study();
	
	// 3) 객체를 생성하는 함수(생성자)를 이용한다 자바의 생성자와 비슷 -> 객체를 생성할 공간ney 연산자가 바놘) 이쪽방법을 제일 많이 문법
	
	
	
	let Student2 = function() { // this -> new 연산자가 만들어낸 메모리 공간
		this.name = null;
		this.grade = 0;
		this.age = 0;
		this.gender = null;
		this.study =function() {
			
		}
	};
	
	let s4 = Student2(); // 틀린표현 생성자함수는 new 연산자와 같이 사용되어야한다 new연산자기 없으면 undefined를 반환함 
 	console.log(s4); // undefined
	//console.log(s4.grade);
	//s4.study();
	
	let s4_2 = new Student2();

	//	4) 클래스 표현법을 사용한다
	class Studenr3 {
		constructot() {
			thid
			this.name = null;
			this.grade = 0;
			this.age = 0
			this.gender- null
			this.gender = ni;;
			this study- function() {
				console.log('공부한다');	}
			
		}
	}.. <!--자바스트립트 내부작으로 3)번 형태로 변경된다 -> 클래스로생성자를 표현하는 문법 트렌드(?)...

	s5 = new Student();
	s5.name = '상디'
	consolel.og(s5.man);
	s5.name3()fs.name;
	
	

	</script>
</head>
<body>

</body>
</html>